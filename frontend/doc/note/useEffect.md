# React 异步编程与 useEffect 深度解析笔记

这份笔记源于一次深入的探讨，旨在彻底厘清 React 开发中两个最核心、也最容易混淆的概念：`useEffect` 的工作机制和 JavaScript 的异步编程模型。

## 第一部分：理解 JavaScript 异步与 `async/await`

### 核心前提：单线程的“厨房”

与拥有 Goroutines（多位厨师）的 Go 不同，浏览器的 JavaScript 环境是一个**单线程**模型，我们只有一个“厨师”——**主线程 (Main Thread)**。

- **同步 (Synchronous)**: 厨师必须一直守在旁边才能完成的操作，如“切菜”。如果“切菜”时间太长，整个厨房（网页UI）都会被卡住。
- **异步 (Asynchronous)**: 厨师只需要“启动”一个设备（如烤箱），然后就可以走开去做别的事。
- **`Promise`**: 就是厨师启动烤箱后，给你的**“取餐小票”**。它承诺“面包烤好后，我会通知你”。
- **`async` / `await`**: 是一种更优雅的、处理“取餐小票”的方式。

### 疑难解答

#### Q1: `const configs = void fetchConfigs()` 中，为什么 `configs` 是 `undefined`？

**A:** 这是因为**函数引用**与**函数调用**的区别。

- `fetchConfigs`: 这只是函数本身，一个**引用**，一张“菜谱”。
- `fetchConfigs()`: 这才是**调用（执行）**函数，是“开始做菜”这个动作。这个动作会立即返回一个 `Promise` (取餐小票)。
- `void` 操作符: 它的唯一作用就是执行它后面的表达式（即 `fetchConfigs()`），然后**立即返回 `undefined`**。它就像是你把菜谱交给厨房后，直接把取餐小票撕掉了。

因此，`const configs = void fetchConfigs()` 实际上是将 `undefined` 赋值给了 `configs` 变量。

#### Q2: `fetchConfigs().then()` 是同步等待吗？

**A:** 不，恰恰相反，`.then()` 是**异步编程的核心**。

- `fetchConfigs()` 立即返回一个 `Promise`。
- `.then()` 的作用是**“预定”一个未来的操作**。它是在告诉 JavaScript 引擎：“嘿，拿着这张取餐小票 (`Promise`)，等菜做好了，请用做好的菜作为参数，去执行我 `.then()` 里面写的这个回调函数。”

在调用了 `.then()` 之后，主线程**不会原地等待**，而是会立刻继续往下执行。

#### Q3: `await` 到底做了什么？它把异步变同步了吗？

**A:** `await` 并没有把异步变同步。它创造了一种“**非阻塞式等待**”的幻觉。

当引擎在一个 `async` 函数中遇到 `await fetchConfigs()` 时：

1. **调用 `fetchConfigs()`**，并拿到返回的 `Promise`。
2. **暂停 `async` 函数**: 引擎会像设置一个“书签”一样，将当前的 `async` 函数在这一行**暂停**。
3. **主线程不阻塞**: 最重要的是，主线程**完全没有被阻塞**！它会立刻跳出这个 `async` 函数，继续去处理其他任务（比如响应用户的下一次鼠标点击）。
4. **恢复执行**: 在未来的某个时刻，当 `Promise` 完成后，引擎会回到“书签”处，将 `Promise` 的结果赋值给变量，然后**继续执行** `async` 函数中 `await` 后面的代码。

#### Q4: 为什么 `await` 必须在 `async` 函数内部使用？

**A:** 这正是 `async/await` 语法的核心契约。`async` 关键字的作用，就是告诉 JavaScript 引擎：“这个函数内部可能会有‘暂停点’（`await`），请为此做好准备”。

因此，为了能在 `useEffect` 内部使用 `await` 这个优雅的语法，我们就必须创建一个临时的、匿名的 `async` 函数，然后立即调用它。这就是**立即调用的异步函数表达式 (Async IIFE)**。

```tsx
useEffect(() => {
  // 创建一个 async 函数，只是为了获得一个可以使用 await 的“魔法空间”
  const fetchData = async () => {
    // 在这个空间里，我们可以像写同步代码一样，优雅地处理异步操作
    const data = await fetchConfigs()
    // ...
  }

  // 立即进入这个“魔法空间”
  void fetchData()
}, [])
```

## 第二部分：精通 `useEffect` Hook

### `useEffect` 的核心职责

`useEffect` 用于处理**副作用 (Side Effects)**。任何与“组件渲染”本身无关的操作，都属于副作用，例如：

- 获取数据 (Data Fetching)
- 设置订阅 (Subscriptions)，如定时器、事件监听
- 手动修改 DOM (在 React 中应尽量避免)

### `useEffect` 的生命周期

#### Q1: `useEffect` 在组件渲染的什么阶段执行？

**A:** `useEffect` 会在**组件完成渲染并被绘制到屏幕上之后**才异步执行。它永远不会阻塞UI的显示。

#### Q2: 为什么我在调试时，看到 `useEffect` 会执行两次？

**A:** 这是由包裹着你 `App` 组件的 **`<React.StrictMode>` (严格模式)** 引起的。

- **作用**: 在**开发模式**下，严格模式会故意将你的 `useEffect` **执行两次**（挂载 -> 卸载 -> 再次挂载）。
- **目的**: 它的目的是为了**帮助你提前发现 bug**。它在模拟用户快速地离开又返回一个页面的场景，以此来检查你的 `useEffect` 是否忘记写“清理函数”，从而导致内存泄漏或状态不一致等问题。
- **请放心**: 这个“执行两次”的行为**只会在开发模式下出现**，生产打包后，`useEffect` 就只会按预期执行一次了。

#### Q3: 依赖项数组 (`dependency array`) 的三种情况

`useEffect` 的执行频率完全取决于它的依赖项数组。

1. **`useEffect(() => { ... }, [])`**: **只执行一次**。
   - 空数组 `[]` 永远不会改变，所以这个 effect 只在组件**首次挂载 (mount)**后运行一次。
   - 最适合：获取初始数据、设置全局监听器等一次性操作。

2. **`useEffect(() => { ... }, [dep1, dep2])`**: **会执行多次**。
   - 会在首次挂载后运行一次。
   - 并且在每一次组件重渲染后，如果 `dep1` 或 `dep2` 的值与上一次渲染时相比**发生了变化**，这个 effect 就会**再次运行**。

3. **`useEffect(() => { ... })`**: **每次渲染都执行**。
   - 如果不提供依赖项数组，这个 effect 会在组件的**每一次**重渲染后都运行。应谨慎使用。

### 清理函数 (Cleanup Function)

#### Q1: 什么时候需要返回一个“清理函数”？

**A:** 当你的副作用创建了一个需要**手动关闭或取消**的“订阅”或资源时，你**必须**返回一个清理函数。

- **需要清理的例子**: `setInterval`, `setTimeout`, `window.addEventListener`, WebSocket 连接。
- **不需要清理的例子**: 一次性的网络请求 (`fetch`)。

#### Q2: “组件下一次重渲染或被销毁前执行它”是什么意思？

**A:** 清理函数的执行时机，总是在**下一次 effect 执行之前** 或 **组件最终销毁之前**。这个机制保证了我们永远不会留下“过时”的、可能导致 bug 的副作用。

**生命周期示例：**

````tsx
useEffect(() => {
  console.log(`为 ID: ${props.id} 创建了订阅`);

  // 返回一个清理函数
  return () => {
    console.log(`正在清理 ID: ${props.id} 的旧订阅`);
  };
}, [props.id]);

```text
**执行流程**:

1. **首次渲染 (`props.id` = 1)**:
    - `useEffect` 执行，打印: `为 ID: 1 创建了订阅`。
2. **`props.id` 变为 2，触发重渲染**:
    - **清理旧 Effect**: 在执行新 effect **之前**，React 先执行上一次留下的清理函数。此时 `props.id` 还是旧的 `1`。打印: `正在清理 ID: 1 的旧订阅`。
    - **执行新 Effect**: 组件用新 props (`id`=2) 完成重渲染。`useEffect` 发现 `props.id` 变化，再次执行。打印: `为 ID: 2 创建了订阅`。
3. **组件被销毁 (unmount)**:
    - 在组件即将从屏幕上消失**之前**，React 会执行**最后一次**的清理函数。此时 `props.id` 是 `2`。打印: `正在清理 ID: 2 的旧订阅`。
````
